use aoc2024::common::read_input;
use regex::Regex;

const DAY: u32 = 4;

pub fn main() {
    let input = day_input();
    let part1_result = part1(&input);
    println!("Day {DAY}, part 1: {part1_result}");
    let part2_result = part2(&input);
    println!("Day {DAY}, part 2: {part2_result}");
}

// Parse input
fn process_input(input: Vec<String>) -> Vec<String> {
    input
}

// Parse sample input
fn _sample_input() -> Vec<String> {
    let data = "MMMSXXMASM
MSAMXMSMSA
AMXSXMAAMM
MSAMASMSMX
XMASAMXAMM
XXAMMXXAMA
SMSMSASXSS
SAXAMASAAA
MAMMMXMMMM
MXMXAXMASX"
        .split('\n')
        .map(|s| s.to_string())
        .collect();
    process_input(data)
}

// Parse day's input
fn day_input() -> Vec<String> {
    process_input(read_input(DAY))
}

// Generated by Copilot
fn transpose(input: &Vec<String>) -> Vec<String> {
    let mut result = vec![];
    for i in 0..input.len() {
        let mut row = String::new();
        for j in 0..input.len() {
            row.push(input[j].chars().nth(i).unwrap());
        }
        result.push(row);
    }
    result
}

// Get all diagonals
fn diagonals(input: &Vec<String>) -> Vec<String> {
    let mut result = vec![];
    // Diagonals that begin from the top (LTR)
    for x in 0..input.len() {
        let mut row = String::new();
        for y in 0..(input.len() - x) {
            row.push(input[y].chars().nth(y + x).unwrap());
        }
        result.push(row);
    }
    // Diagonals that begin from the top (RTL)
    for x in (0..input.len()).rev() {
        let mut row = String::new();
        for y in 0..(x + 1) {
            row.push(input[y].chars().nth(x - y).unwrap());
        }
        result.push(row);
    }
    // Diagonals that begin from the left (LTR)
    for y in 1..input.len() {
        let mut row = String::new();
        for x in 0..(input.len() - y) {
            row.push(input[y + x].chars().nth(x).unwrap());
        }
        //println!("{}", row);
        result.push(row);
    }
    // Diagonals that begin from the right (RTL)
    for y in (1..input.len()).rev() {
        //println!("y={}", y);
        let mut row = String::new();
        for x in y..input.len() {
            //println!("x={}", x);
            //println!("({},{})", x, y + (input.len() - 1 - x));
            row.push(input[y + (input.len() - 1 - x)].chars().nth(x).unwrap());
        }
        //println!("{}", row);
        result.push(row);
    }
    result
}

fn part1(input: &Vec<String>) -> i64 {
    // Count the occurences of "XMAS" and "SMAX" in the input
    fn count_occurences(source: &Vec<String>) -> i64 {
        let target1 = "XMAS";
        let target2 = "SAMX";
        source
            .iter()
            .map(|s| s.matches(target1).count() + s.matches(target2).count())
            .sum::<usize>() as i64
    }

    let rows: i64 = count_occurences(input);
    let cols = count_occurences(&transpose(input));
    let diagonals = count_occurences(&diagonals(input));
    rows + cols + diagonals
}

fn part2(input: &Vec<String>) -> i64 {
    let xmas = Regex::new(r"^(?:M.M.A.S.S|M.S.A.M.S|S.M.A.S.M|S.S.A.M.M)$").unwrap();
    // Iterate through all possible starting points (topleft) for xmas shape
    (0..(input.len() - 2))
        .map(|x| {
            (0..(input.len() - 2))
                .filter(|&y| {
                    let combined: String = (y..(y + 3))
                        .fold(String::new(), |t, y1| t + &input[y1][x..x + 3].to_string());
                    xmas.is_match(&combined)
                })
                .count() as i64
        })
        .sum::<i64>()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part1() {
        let input = _sample_input();
        assert_eq!(18, part1(&input));
    }

    #[test]
    fn test_part2() {
        let input = _sample_input();
        assert_eq!(9, part2(&input));
    }

    #[test]
    fn real_part1() {
        let input = day_input();
        assert_eq!(2554, part1(&input));
    }

    #[test]
    fn real_part2() {
        let input = day_input();
        assert_eq!(1916, part2(&input));
    }
}
